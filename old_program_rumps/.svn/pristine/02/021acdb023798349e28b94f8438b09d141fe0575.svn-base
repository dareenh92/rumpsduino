//------------------------------------------------------------------------------
//
// Main Program
// Application		: spi_lms6002d test
// Core						: Any
// Purpose
//	- Test of controlling Lime LMS6002D register

#include "main.h"
const char RESETn = 26; // Lime hardware reset, GPIO7

void write_lms6002_reg(uint8_t reg_addr, uint8_t data);
uint8_t read_lms6002_reg(uint8_t reg_addr);

void main_scheduler (void);

//------------------------------------------------------------------------------
int main(void)
{
  char ch;
  uint8_t reg_addr;
  uint8_t data_w;
  uint8_t data_r;
  
  //
  pinMode_output(RESETn);
  digitalWrite_high(RESETn);
  
   	  	 // CPHA, CPOL, BC,   IE,   FSB,  SS,   CR
  spi_init( 0x0,  0x0,  0x1,  0x0,  0x0,  0x1,  0x1);
  spi_enable();
  
  // mux
  MUXC_SELECT = 0x00000040;	// SPI selected
  MUXC_PU &= 0x0fffffff;	// SPI PU disabled
  
  uart_hd_init_uart(0x1);
  
  while(1){
  	// receive command from terminal
    ch = uart_hd_getchar();
    
    if(ch=='s'){
      //####
      // TOP Level
      //####
      // Soft tx enable
      reg_addr = 0x05; data_w = 0x3a;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      // Clock buffers - Tx DSM SPI
      reg_addr = 0x09; data_w = 0x01;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      //####
      // Tx LPF and Gain
      //####
      // Tx LPF - select LPF bandwidth
      reg_addr = 0x34; data_w = 0x02;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      // Tx RF - VGA1 gain (-10dB)
      reg_addr = 0x41; data_w = 0x19;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      // Tx RF - Select PA1
      reg_addr = 0x44; data_w = 0x0B;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      // Tx RF - VGA2 gain (15dB)
      reg_addr = 0x45; data_w = 0x78;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      //####
      // Tx PLL + DSM
      //####
      // Output frequency - .81 to .93 GHz
      reg_addr = 0x15; data_w = 0xf8;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      // CP current 
      reg_addr = 0x16; data_w = 0x8c;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      // CP UP offset current
      reg_addr = 0x17; data_w = 0x7e;
      write_lms6002_reg(reg_addr, data_w);
      data_r = read_lms6002_reg(reg_addr);
      uart_hd_putchar(data_r);
      
      // Fine tune VCO cap
    }
    
    else if(ch=='r'){
      //hardware reset
      digitalWrite_low(RESETn);
      for (int i=0; i<1000; i++)__NOP();
      digitalWrite_high(RESETn);
    }
    
  }
   
	return 0;
}
  
void write_lms6002_reg(uint8_t reg_addr, uint8_t data){
  //takes 7 bits, add CMD=1 for write on MSB
  reg_addr = (reg_addr & 0x7f) | 0x80;
	  
  spi_send( (reg_addr << 8) | (data & 0xff) );
}

uint8_t read_lms6002_reg(uint8_t reg_addr){
  //takes 7 bits, add CMD=0 for read on MSB
  reg_addr = (reg_addr & 0x7f);

  //do transfer
 	spi_send((reg_addr << 8));
  
  while ((SPI_STATE & 0x1) == 0x0) // wait SP_IF high
    __NOP();
	
  SPI_STATE |= 0x1; // write 1 to clear
  
  return (SPI_DATA & 0xff);
}

